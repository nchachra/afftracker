var ATBg = {

  /*
   * Debugging flag
   */
  debug: false,

  /**
   * We track all requests as possibly affiliate URL requests. These are
   * indexed by a unique request ID generated by Chrome. Either when we
   * establish this request is not related to an affiliate, or when a
   * timeout happens, we stop tracking this request and delete the state.
   *
   * @private
   */
  probableSubmissions: {},


  /**
   * Unique identifier for this user. Generated at initialization and stored
   * in local storage using USER_ID_STORAGE_KEY.
   *
   * @private
   */
  userId: null,


  /**
   * Queue for objects before they are sent to server in batches.
   *
   * @private
   */
  submissionQueue: [],


  /**
   * Custom logging. Only logs if debug flag is set.
   *
   * @param{object} msg Message directly passed to console.log.
   */
  log: function(msg) {
    if (this.debug)
      console.log(msg);
  },


  /**
   * Sends a list of currently installed extensions to the server. We send
   * the extension name, id, and description. Exclude extensions that Chrome
   * seems to ship with already.
   */
  processExistingExtensions: function() {
    var pendingExtSubmissions = [];
    chrome.management.getAll(function(extensions) {
      extensions.forEach(function (extension, index) {
        // Exclude default extensions.
        if (["Google Docs", "Google Drive", "YouTube", "Google Search",
            "Gmail", "AffiliateTracker",
            "Chrome Apps & Extensions Developer Tool", "Google Translate",
            ].indexOf(extension.name) == -1) {
          var ob = {"name": extension.name,
                    "id": extension.id,
                    "description": extension.description,
                    "userId": ATBg.userId,
                    "timestamp": new Date().getTime() / 1000,
                    "enabled": extension.enabled,
          }
          pendingExtSubmissions.push(ob);
        }
      });
      if (pendingExtSubmissions.length > 0) {
        data = JSON.stringify(pendingExtSubmissions);
        // Effectively clears array:
        // http://stackoverflow.com/questions/1232040/empty-an-array-in-javascript
        pendingExtSubmissions.length = 0;
        ATUtils.sendXhr(data, "extension");
      }
    });
  },


  /**
   * Looks through all the cookies in the cookie store to find affiliate
   * cookies. We exclude CJ cookies because we can't determine either
   * the merchant or the affiliate id from the cookie itself.
   */
  processExistingCookies: function() {
    chrome.cookies.getAll({}, function(cookies) {
      cookies.forEach(function(cookie, index) {
        if (cookie.name !== "LCLK") {
          if (AT_CONSTANTS.cookieAffRe.test(cookie.name + "=" + cookie.value)) {
            var merchant = ATParse.getMerchant("Cookie", [cookie.domain,
              cookie.name]);
            // We identified an affiliate cookie.
            var affId = ATParse.parseAffiliateId(merchant,
              cookie.name + "=" + cookie.value, "COOKIE");
            // Don't bother processing if we can't determine neither merchant
            // nor affiliate
            if (affId || merchant) {
              ATBg.processExistingAffCookie(affId, merchant, cookie);
            }
          }
        }
      });
    });
  },


  /**
   * Locally saves information about a cookie for displaying to the user. A
   * tiny object is created per merchant which stores information about the
   * most recent affiliate cookie that the extension knows of.
   *
   * @param{string} affId Affiliate identifier.
   * @param{string} merchant It's the domain name of merchant.
   * @param{object} cookie The internal cookie object.
   *
   * @private
   */
  processExistingAffCookie: function(affId, merchant, cookie) {
    var sub = new ATSubmission();
    sub.setAffiliate(affId);
    sub.setMerchant(merchant);
    sub.setCookie(cookie);
    ATBg.storeInLocalStorage(sub);
    ATBg.queueForSubmission(sub);
  },


  /**
   * @param{object} submissionObj Object to be eventually sent to server.
   */
  queueForSubmission: function(submissionObj) {
    ATBg.submissionQueue.push(submissionObj);
  },


  /**
   * Stores information about cookie in local storage. This data is
   * referenced before a popup is displayed to the user. Only a small
   * subset of the submission object is stored.
   *
   * @param{submissionObj} The object whose subset is stored.
   */
  storeInLocalStorage: function(submissionObj) {
    var storeObj = {};
    var storage_key = AT_CONSTANTS.KEY_ID_PREFIX + submissionObj["merchant"];
    storeObj[storage_key] = {
                              "affiliate" : submissionObj.affiliate,
                              "cookie": submissionObj.cookie.value,
                              "cookieDomain": submissionObj.cookie.domain,
                              "origin": submissionObj.origin,
                             };
    // We only care about the last cookie value written
   chrome.storage.sync.set(storeObj, function() {
      //console.log("stored in local storage", storeObj);
    });
  },


  /**
   * Sends objects about all the cookies currently in the submission queue
   * to the server.
   *
   * @private
   */
  sendCookiesToServer: function() {
    // Send messages up to length
    var len = ATBg.submissionQueue.length;
    if (len > 0) {
      // Frees up memory because we are calling splice.
      ATUtils.sendXhr(JSON.stringify(ATBg.submissionQueue.splice(0, len)),
          "cookie");
    }
  },


  /**
   * Finds the frame with corresponding URL in the submission object, and
   * when it figures out the DOM details, it adds the object to the submission
   * queue.
   *
   * @param{object} submissionObj Object to which DOM data should be added.
   * @param {integer} tabId
   * @return {object} Object containing parameters like width, height, etc.
   * @private
   */
  addDomDataAndPushToSubmission: function(submissionObj, tabId) {
    if (["script", "stylesheet", "main_frame"].
        indexOf(submissionObj["type"]) == -1) {
      //ATBg.log("trying to get frame properties for " +
      //    submissionObj["culpritReqUrl"] + " frame: " +
      //    submissionObj["type"] + " for tab: " + tabId);
      chrome.tabs.sendMessage(tabId, {"method": "getAffiliateDom",
          "frameType": submissionObj["type"],
          "url": submissionObj["culpritReqUrl"]}, function(response) {
        submissionObj["domEls"] = response;
      });
    } else {
      submissionObj["domEls"] = null;
    }
  },


  /**
   * Returns the partially initialized submission object corresponding to
   * the request id. Returns null if no such object exists.
   *
   * @param{string} requestId The request Id that is used to index submission
   *    objects.
   * @return{object} Submission object if one was found, null otherwise.
   */
  getProbableSubmission: function(requestId) {
    // If this request has gone over 10 seconds, it would have been deleted
    // by a timer.
    if (!ATBg.probableSubmissions.hasOwnProperty(requestId)) {
      return null;
    }
    return ATBg.probableSubmissions[requestId];
  },


  /**
   * Parses and adds values to the submission object. This object is eventually
   * sent to the server. Either the cookie object needs to be suppied or
   * the response and cookieHeaderValue. CookieValue is only temporarily
   * stored in submissionObj because we need it in local storage. It is
   * removed from submission object before being sent to the server.
   *
   * @param{object} submissionObj Object to which values should be added.
   * @param{string} cookieHeaderValue The value of the set-cookie header.
   * @param{string} affId The parsed out affiliate ID.
   * @param{object} response Response object, can be null.
   * @param{object} cookie Optional cookie object.
   */
  updateSubmissionObj: function(submissionObj, cookieHeaderValue, affId,
      response, merchant) {
    if (response && cookieHeaderValue) {
      // This object will be sent to server and deleted when that happens.
      clearTimeout(submissionObj["reqLifeTimer"]);
      delete submissionObj["reqLifeTimer"];

      submissionObj["sendMonitorInterval"] = setInterval(function(){
        if (submissionObj.hasOwnProperty("landing") &&
            submissionObj.hasOwnProperty("domEls") &&
            submissionObj.hasOwnProperty("origin") &&
            submissionObj.hasOwnProperty("culpritReqUrl") &&
            submissionObj.hasOwnProperty("type") &&
            submissionObj.hasOwnProperty("newTab")) {
          clearInterval(submissionObj["sendMonitorInterval"]);
          delete submissionObj["sendMonitorInterval"];
          ATBg.queueForSubmission(submissionObj);
          chrome.tabs.sendMessage(submissionObj["tabId"],
            {"method": "highlightAffiliateDom",
            "frameType": submissionObj["type"],
            "url": submissionObj["culpritReqUrl"]}, function(response) {
          });
        }
      }, 1000);

      submissionObj["cookieName"] = cookieHeaderValue.substring(0,
          cookieHeaderValue.indexOf("="));
      var cookieVal = (cookieHeaderValue.indexOf(";") == -1) ?
          cookieHeaderValue.substring(cookieHeaderValue.indexOf("=")) :
          cookieHeaderValue.substring(cookieHeaderValue.indexOf("=") + 1,
              cookieHeaderValue.indexOf(';'));

      submissionObj["cookieValue"] = cookieVal;
      //submissionObj["cookieHash"] = CryptoJS.MD5(cookieVal).toString(
      //    CryptoJS.enc.Hex);
      submissionObj["cookieDomain"] = ATParse.
          getCookieParameter(cookieHeaderValue, "domain", response.url);
      submissionObj["cookiePath"] = ATParse.getCookieParameter(
          cookieHeaderValue, "path", response.url);
      submissionObj["cookieExpDate"] = ATParse.
          getCookieParameter(cookieHeaderValue, "expires", "");
      submissionObj["userId"] = ATUtils.getUserId();
      submissionObj["affId"] = affId;
      submissionObj["timestamp"] = response.timeStamp;
      submissionObj["cookieSrc"] = "traffic";
      submissionObj["cookieUrl"] = response.url;
      if (merchant == "") {
        merchant = ATUtils.getMerchant("Cookie",
            [submissionObj["cookieDomain"], submissionObj["cookieName"]]);
      }
      submissionObj["merchant"] = merchant;
      // Every submission object which will be subsequently submitted has
      // a timer that flags the object as ready for submission, even if we
      // never figured out its dom.
      submissionObj["domTimer"] = setTimeout(function() {
        //ATBg.log("dom timer fired. Setting dom els to null, deleting timer");
        submissionObj["domEls"] = null;
        delete submissionObj["domTimer"];
      }, 60000);

    }
 },


  /**
   * Adds the landing page to the submission object.
   *
   * @param{object} submissionObject Submission object to be augmented.
   * @param{object} response The response containing tabId
   */
  addLandingPageToSubmission: function(submissionObj, response) {
    chrome.tabs.get(response.tabId, function(tab) {
      var landing = (typeof tab != "undefined") ? tab.url : null;
      // Chrome doesn't update the tab url right away, so sometimes we get
      // the wrong results.
      if (response.type == "main_frame" &&
          response.url != landing) {
        landing = response.url;
      }
      submissionObj["landing"] = landing;
    });
  },


  /**
   * Shows a notification to the user.
   *
   */
  notifyUser: function(merchant, origin) {
    var notificationOpts = {
        type: 'basic',
        iconUrl: 'icon.png',
        title: merchant + " cookie",
        message: "From " + origin
     }

    chrome.notifications.clear(AT_CONSTANTS.NOTIFICATION_ID, function(){
      // TODO: error handling?
     });

    chrome.notifications.update(AT_CONSTANTS.NOTIFICATION_ID,
        notificationOpts, function(wasUpdated) {
      if (!wasUpdated) {
        chrome.notifications.create(AT_CONSTANTS.NOTIFICATION_ID,
            notificationOpts, function() {});
      }
    });
    setTimeout(function() {
      chrome.notifications.clear(AT_CONSTANTS.NOTIFICATION_ID,
          function() {});
    }, 2000);
  },


  /**
   * Adds some request/response parameters to the submission object.
   *
   * @param{object} submissionObj Object likely to be submitted.
   * @param{object} webRequest Request or response object.
   */
  updateReqRespSeq: function(submissionObj, webRequest) {
    if (!submissionObj.hasOwnProperty("reqRespSeq")) {
      submissionObj["reqRespSeq"] = [];
    }
    submissionObj.reqRespSeq.push({
        "method": webRequest.method,
        "timestamp": webRequest.timestamp,
        "type": webRequest.type,
        "url": webRequest.url,
        "statusLine": (webRequest.hasOwnProperty("statusLine") ?
                       webRequest.statusLine : null)
    });
  },


  /**
   * Submission objects for a given tabId.
   *
   * @param{integer} tabId
   * @return{array} List of submission objects.
   */
  getSubmissionObjectsForTabId: function(tabId) {
    var matchingObjs = [];
    for (requestId in ATBg.probableSubmissions) {
      if (ATBg.probableSubmissions.hasOwnProperty(requestId)) {
        var candidate = ATBg.probableSubmissions[requestId];
        if (!candidate.hasOwnProperty("domEls") &&
            candidate.hasOwnProperty("tabId") && candidate.tabId == tabId) {
            matchingObjs.push(candidate);
        }
      }
    }
    return matchingObjs;
  },


  /**
   * When a tab completes loading, we check if the corresponding submission
   * object is still around and does not have the DOM data in it already.
   * If so, we query data for the DOM element with affiliate URL, add it
   * to the submission queue, and clear its DOM request timer.
   * If no such submission object exists, we ignore the data.
   *
   * @param{string} tabId The id of the tab that finished loading.
   * @param{string} changeInfo The status of the page.
   * @param{object} Tab object.
   */
  tabLoadCallback: function(tabId, changeInfo, tab) {
    if (changeInfo.status == "complete") {
      var submissionObjects = ATBg.getSubmissionObjectsForTabId(tabId);
      submissionObjects.forEach(function(obj) {
        clearTimeout(obj["domTimer"]);
        delete obj["domTimer"];
        ATBg.addDomDataAndPushToSubmission(obj, tab.id);
      });
    }
  },


  /**
   * Intercept every response. If a request corresponds to affiliate URL
   * determined by looking at the Set-Cookie headers, then parse out useful
   * information, store it in local storage and server, notify user,
   * free up space.
   *
   * @param{Webrequest} response
   */
  responseCallback: function(response) {
    var submissionObj = ATBg.getProbableSubmission(response.requestId);

    if (submissionObj) {
      ATBg.updateReqRespSeq(submissionObj, response);
      var setCookieHeaders = response.responseHeaders.filter(function(header) {
        return header.name.toLowerCase() == "set-cookie";
      });

      setCookieHeaders.forEach(function(header) {
        if (AT_CONSTANTS.cookieAffRe.test(header.value) &&
            // Bluehost 301 redirects from tracking URL to bluehost.com and
            // sends 2 cookies called r. The one set for .bluehost.com is
            // empty. The real cookie is the one set for www.bluehost.com.
            !header.value.indexOf("domain=.bluehost.com;") != -1 &&
            // Some merchants will set the same cookie as affiliate window
            // with their domains. Ignore those, it's redundant info for us.
            !(header.value.indexOf("aw") == 0 &&
              header.value.indexOf("domain=.awin1.com;") == -1)) {

          // Normally we only get a set-cookie once for a merchant, but for
          // CJ, we go through multiple hops, of which only some of them
          // yield the affiliate id and merchant id. The most reliable one is
          // the referrer to the URL that results in the LCLK cookie.
          var merchant = null;
          var cjUrl = null;
          if (!submissionObj.hasOwnProperty("merchant")) {
            // For CJ, the URL with merchant is actually the penultimate one.
            if (header.value.indexOf("LCLK=") == 0 &&
                submissionObj.hasOwnProperty("reqRespSeq")) {
              var cjUrl = ATParse.findCJUrlInReqSeq(submissionObj.reqRespSeq);
              if (cjUrl) {
                merchant = ATParse.getMerchant("URL", [cjUrl]);
              } else {
                // Some CJ urls are encrypted and we won't get a merchant
                // for those. Landing page may be used for these. Punting
                // in the notification for now.
                merchant = "commission junction";
              }
            } else {
              merchant = ATParse.getMerchant("URL", [response.url]);
            }

            submissionObj["merchant"] = merchant;
          } else {
            merchant = submissionObj["merchant"];
          }

          var affId = null;
          if (submissionObj.hasOwnProperty("affId")) {
            affId = submissionObj.affId;
          } else {
            if (AT_CONSTANTS.AMAZON_SITES.indexOf(merchant) != -1) {
              affId = ATParse.parseAffiliateId(merchant, response.url, "URL");
            } else if (header.value.indexOf ("LCLK=") == 0) {
              // Commission Junction
              affId = ATParse.parseAffiliateId(merchant, cjUrl, "URL");
            } else {
              affId = ATParse.parseAffiliateId(merchant, header.value, "COOKIE");
            }
            submissionObj["affId"] = affId;
          }

          if (affId) {
            // yielding the final page, so we aren't ready to submit.
            ATBg.updateSubmissionObj(submissionObj, header.value, affId,
                response, merchant);
            ATBg.notifyUser(submissionObj["merchant"],
                submissionObj["origin"]);
          }
        }
      });
      if (submissionObj.hasOwnProperty("affId") &&
          response.statusLine.indexOf("200") !== -1) {
        ATBg.addLandingPageToSubmission(submissionObj, response);
        ATBg.storeInLocalStorage(submissionObj);
      }
    }
  },


  /**
   * Intercept every outgoing request to partially initialize a submission
   * object. We finish processing when we receive a reponse with a cookie. All
   * submission objects are tracked using the unique request ids Chrome
   * generates for a single request chain.
   *
   * A single request ID may appear multiple times in either request or
   * response. We store some of the parameters in these cases.
   *
   * Lastly, all probably submission objects have an associated timer that
   * destroys them at the end of 30 seconds if no response with a cookie was
   * received during this time.
   *
   * @param{Webrequest} request
   */
  requestCallback: function(request) {
    var submissionObj = ATBg.getProbableSubmission(request.requestId);
    if (!submissionObj) {
      submissionObj = {};
      // Origin is the page that requested merchant URL for affiliate.
      // Landing is the page that the user saw in the end.
      // newTab determines whether the mechant URL was requested in new tab.
      if (request.tabId >= 0 && !chrome.runtime.lastError) {
        chrome.tabs.get(request.tabId, function(tab) {
          if (typeof tab !== "undefined" && tab !== null) {
            submissionObj["culpritReqUrl"] = request.url;
            submissionObj["type"] = request.type;
            if (tab.hasOwnProperty("openerTabId") &&
                typeof tab.openerTabId !== "undefined") {
              chrome.tabs.get(tab.openerTabId, function(openerTab) {
                if (openerTab !== null) {
                  submissionObj["origin"] = openerTab.url;
                  submissionObj["newTab"] = true;
                }
              });
            } else {
              submissionObj["newTab"] = false;
            }
            submissionObj["origin"] = tab.url;
          }
        });
      }
      submissionObj["reqLifeTimer"] = setTimeout(function() {
        if (ATBg.probableSubmissions.hasOwnProperty(
          request.requestId)) {
          // Delete this object reference.
          delete ATBg.probableSubmissions[request.requestId];
        }
      }, 10000);
      // We use this to find DOM content later. If tabId is -1, the request is
      // not related to a tab.
      submissionObj["tabId"] = request.tabId;
      ATBg.probableSubmissions[request.requestId] = submissionObj;
    }
    ATBg.updateReqRespSeq(submissionObj, request);
    // Array.prototype.find does not work, using this instead.
    // This is redundant, but I keep over-writing to get final referer.
    var refererHeaders = request.requestHeaders.filter(function(header) {
      return header.name.toLowerCase() == "referer";
    });
    if (refererHeaders.length > 0) {
      submissionObj["referer"] = refererHeaders[0].value;
    }
  },
};
